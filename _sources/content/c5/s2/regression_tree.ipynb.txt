{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Regression Trees"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np \n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn import datasets"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [],
   "source": [
    "tips = sns.load_dataset('tips')\n",
    "X = np.array(tips.drop(columns = 'tip'))\n",
    "y = np.array(tips['tip'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "def RSS_reduction(child_L, child_R, parent):\n",
    "    rss_parent = sum((parent - np.mean(parent))**2)\n",
    "    rss_child_L = sum((child_L - np.mean(child_L))**2) \n",
    "    rss_child_R = sum((child_R - np.mean(child_R))**2)\n",
    "    return rss_parent - (rss_child_L + rss_child_R)\n",
    "\n",
    "def sort_x_by_y(x, y):\n",
    "    unique_xs = np.unique(x)\n",
    "    y_mean_by_x = np.array([y[x == unique_x].mean() for unique_x in unique_xs])\n",
    "    ordered_xs = unique_xs[np.argsort(y_mean_by_x)]\n",
    "    return ordered_xs\n",
    "\n",
    "def all_rows_equal(X):\n",
    "    return (X == X[0]).all()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Node:\n",
    "    \n",
    "    def __init__(self, Xsub, ysub, ID, depth = 0, parent_ID = None, leaf = True):\n",
    "        self.ID = ID\n",
    "        self.Xsub = Xsub\n",
    "        self.ysub = ysub\n",
    "        self.size = len(ysub)\n",
    "        self.depth = depth\n",
    "        self.parent_ID = parent_ID\n",
    "        self.leaf = leaf\n",
    "        \n",
    "class Splitter:\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.rss_reduction = 0\n",
    "        \n",
    "    def replace_split(self, rss_reduction, d, dtype = 'quant', t = None, L_values = None):\n",
    "        self.rss_reduction = rss_reduction\n",
    "        self.d = d\n",
    "        self.dtype = dtype\n",
    "        self.t = t        \n",
    "        self.L_values = L_values        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DecisionTreeRegressor:\n",
    "    \n",
    "    #############################\n",
    "    ######## 1. TRAINING ########\n",
    "    #############################\n",
    "    \n",
    "    ######### FIT ##########\n",
    "    def fit(self, X, y, max_depth = 100, min_size = 2):\n",
    "        \n",
    "        ## Add data\n",
    "        self.X = X\n",
    "        self.y = y\n",
    "        self.N, self.D = self.X.shape\n",
    "        dtypes = [np.array(list(self.X[:,d])).dtype for d in range(self.D)]\n",
    "        self.dtypes = ['quant' if (dtype == float or dtype == int) else 'cat' for dtype in dtypes]\n",
    "        \n",
    "        ## Add regularization parameters\n",
    "        self.max_depth = max_depth\n",
    "        self.min_size = min_size\n",
    "        \n",
    "        ## Initialize nodes\n",
    "        self.nodes_dict = {}\n",
    "        self.current_ID = 0\n",
    "        initial_node = Node(Xsub = X, ysub = y, ID = self.current_ID, parent_ID = None)\n",
    "        self.nodes_dict[self.current_ID] = initial_node\n",
    "        self.current_ID += 1\n",
    "        \n",
    "        ## Build\n",
    "        self.build()\n",
    "        \n",
    "        ## Calculate leaf means\n",
    "        self.get_leaf_means()\n",
    "     \n",
    "    \n",
    "    ###### FIND SPLIT ######\n",
    "    def find_split(self, bud):\n",
    "        \n",
    "        ## Instantiate splitter\n",
    "        splitter = Splitter()\n",
    "        splitter.bud_ID = bud.ID\n",
    "        \n",
    "        ## For each predictor...\n",
    "        for d in range(self.D):\n",
    "            Xsub_d = bud.Xsub[:,d]\n",
    "            dtype = self.dtypes[d]\n",
    "            if len(np.unique(Xsub_d)) == 1:\n",
    "                continue\n",
    "\n",
    "            ## For each threshold value...\n",
    "            if dtype == 'quant':\n",
    "                for t in np.unique(Xsub_d)[:-1]:\n",
    "                    ysub_L = bud.ysub[Xsub_d <= t]\n",
    "                    ysub_R = bud.ysub[Xsub_d > t]\n",
    "                    rss_reduction = RSS_reduction(ysub_L, ysub_R, bud.ysub)\n",
    "                    if rss_reduction > splitter.rss_reduction:\n",
    "                        splitter.replace_split(rss_reduction, d, dtype = 'quant', t = t)\n",
    "            else:\n",
    "                ordered_x = sort_x_by_y(Xsub_d, bud.ysub)\n",
    "                for i in range(len(ordered_x) - 1):\n",
    "                    L_values = ordered_x[:i+1]\n",
    "                    ysub_L = bud.ysub[np.isin(Xsub_d, L_values)]\n",
    "                    ysub_R = bud.ysub[~np.isin(Xsub_d, L_values)]\n",
    "                    rss_reduction = RSS_reduction(ysub_L, ysub_R, bud.ysub)\n",
    "                    if rss_reduction > splitter.rss_reduction: \n",
    "                        splitter.replace_split(rss_reduction, d, dtype = 'cat', L_values = L_values)\n",
    "        ## Save splitter\n",
    "        self.splitter = splitter\n",
    "        \n",
    "    ###### MAKE SPLIT ######\n",
    "    def make_split(self):\n",
    "        ## Update parent node\n",
    "        parent_node = self.nodes_dict[self.splitter.bud_ID]\n",
    "        parent_node.leaf = False\n",
    "        parent_node.child_L = self.current_ID\n",
    "        parent_node.child_R = self.current_ID + 1\n",
    "        parent_node.d = self.splitter.d\n",
    "        parent_node.dtype = self.splitter.dtype\n",
    "        parent_node.t = self.splitter.t        \n",
    "        parent_node.L_values = self.splitter.L_values\n",
    "        \n",
    "        ## Get X and y data for children\n",
    "        if parent_node.dtype == 'quant':\n",
    "            L_condition = parent_node.Xsub[:,parent_node.d] <= parent_node.t\n",
    "     \n",
    "        else:\n",
    "            L_condition = np.isin(parent_node.Xsub[:,parent_node.d], parent_node.L_values)\n",
    "        Xchild_L = parent_node.Xsub[L_condition]\n",
    "        ychild_L = parent_node.ysub[L_condition]\n",
    "        Xchild_R = parent_node.Xsub[~L_condition]\n",
    "        ychild_R = parent_node.ysub[~L_condition]\n",
    "\n",
    "        \n",
    "        ## Create child nodes\n",
    "        child_node_L = Node(Xchild_L, ychild_L, depth = parent_node.depth + 1,\n",
    "                            ID = self.current_ID, parent_ID = parent_node.ID)\n",
    "        child_node_R = Node(Xchild_R, ychild_R, depth = parent_node.depth + 1,\n",
    "                            ID = self.current_ID+1, parent_ID = parent_node.ID)\n",
    "        self.nodes_dict[self.current_ID] = child_node_L\n",
    "        self.nodes_dict[self.current_ID + 1] = child_node_R\n",
    "        self.current_ID += 2\n",
    "    \n",
    "    ###### BUILD TREE ######\n",
    "    def build(self):\n",
    "        \n",
    "        eligible_buds = self.nodes_dict \n",
    "        for layer in range(self.max_depth):\n",
    "            \n",
    "            ## Find eligible nodes for layer iteration\n",
    "            eligible_buds = {ID:node for (ID, node) in self.nodes_dict.items() if \n",
    "                                (node.leaf == True) &\n",
    "                                (node.depth == layer) &\n",
    "                                (node.size >= self.min_size) & \n",
    "                                (~all_rows_equal(node.Xsub)) &\n",
    "                                (len(np.unique(node.ysub)) > 1)}\n",
    "            if len(eligible_buds) == 0:\n",
    "                break\n",
    "                \n",
    "            ## split each eligible parent\n",
    "            for ID, bud in eligible_buds.items():\n",
    "                                \n",
    "                ## Find split\n",
    "                self.find_split(bud)\n",
    "                \n",
    "                ## Make split\n",
    "                self.make_split()\n",
    "                \n",
    "    ###### LEAF MEANS ######\n",
    "    def get_leaf_means(self):\n",
    "        self.leaf_means = {}\n",
    "        for node_ID, node in self.nodes_dict.items():\n",
    "            if node.leaf:\n",
    "                self.leaf_means[node_ID] = node.ysub.mean()\n",
    "\n",
    "            \n",
    "    #############################\n",
    "    ####### 2. PREDICTING #######\n",
    "    #############################\n",
    "    \n",
    "    ####### PREDICT ########\n",
    "    def predict(self, X_test):\n",
    "        yhat = []\n",
    "        for x in X_test:\n",
    "            node = self.nodes_dict[0] \n",
    "            while not node.leaf:\n",
    "                if node.dtype == 'quant':\n",
    "                    if x[node.d] <= node.t:\n",
    "                        node = self.nodes_dict[node.child_L]\n",
    "                    else:\n",
    "                        node = self.nodes_dict[node.child_R]\n",
    "                else:\n",
    "                    if x[node.d] in node.L_values:\n",
    "                        node = self.nodes_dict[node.child_L]\n",
    "                    else:\n",
    "                        node = self.nodes_dict[node.child_R]\n",
    "            yhat.append(self.leaf_means[node.ID])\n",
    "        return np.array(yhat)\n",
    "            \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(123)\n",
    "test_frac = 0.25\n",
    "test_size = int(len(y)*test_frac)\n",
    "test_idxs = np.random.choice(np.arange(len(y)), test_size, replace = False)\n",
    "X_train = X[~test_idxs]\n",
    "y_train = y[~test_idxs]\n",
    "X_test = X[test_idxs]\n",
    "y_test = y[test_idxs]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [],
   "source": [
    "tree = DecisionTreeRegressor()\n",
    "tree.fit(X_train, y_train, max_depth = 5, min_size = 5)\n",
    "y_test_hat = tree.predict(X_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "sns.scatterplot(y_train, tree.predict(X_train));"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
